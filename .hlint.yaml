- arguments:
  - -XConstraintKinds
  - -XDeriveGeneric
  - -XGeneralizedNewtypeDeriving
  - -XLambdaCase
  - -XOverloadedStrings
  - -XRecordWildCards
  - -XScopedTypeVariables
  - -XStandaloneDeriving
  - -XTupleSections
  - -XTypeApplications
  - -XViewPatterns
- ignore:
    name: Use head
- ignore:
    name: Use Foldable.forM_
- hint:
    lhs: (pure ())
    note: Use 'pass'
    rhs: pass
- hint:
    lhs: (return ())
    note: Use 'pass'
    rhs: pass
- warn:
    lhs: Control.Exception.evaluate
    rhs: evaluateWHNF
- warn:
    lhs: Control.Exception.evaluate (force x)
    rhs: evaluateNF x
- warn:
    lhs: Control.Exception.evaluate (x `deepseq` ())
    rhs: evaluateNF_ x
- warn:
    lhs: void (evaluateWHNF x)
    rhs: evaluateWHNF_ x
- warn:
    lhs: void (evaluateNF x)
    rhs: evaluateNF_ x
- hint:
    lhs: (Control.Exception.throw)
    note: Use 'impureThrow'
    rhs: impureThrow
- hint:
    lhs: (foldl' (flip f))
    note: Use 'flipfoldl''
    rhs: flipfoldl' f
- warn:
    lhs: foldl' (+) 0
    rhs: sum
- warn:
    lhs: foldl' (*) 1
    rhs: product
- hint:
    lhs: (fmap and (sequence s))
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: andM s
- hint:
    lhs: (and <$> sequence s)
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: andM s
- hint:
    lhs: (fmap or (sequence s))
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: orM s
- hint:
    lhs: (or <$> sequence s)
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: orM s
- hint:
    lhs: (fmap and (mapM f s))
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: allM f s
- hint:
    lhs: (and <$> mapM f s)
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: allM f s
- hint:
    lhs: (fmap or (mapM f s))
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: anyM f s
- hint:
    lhs: (or <$> mapM f s)
    note: Applying this hint would mean that some actions that were being executed
      previously would no longer be executed.
    rhs: anyM f s
- warn:
    lhs: map fst &&& map snd
    rhs: unzip
- hint:
    lhs: (fmap (fmap f) x)
    note: Use '(<<$>>)'
    rhs: f <<$>> x
- hint:
    lhs: ((\f -> f x) <$> ff)
    note: Use flap operator
    rhs: ff ?? x
- hint:
    lhs: (fmap (\f -> f x) ff)
    note: Use flap operator
    rhs: ff ?? x
- hint:
    lhs: (fmap ($ x) ff)
    note: Use flap operator
    rhs: ff ?? x
- hint:
    lhs: (($ x) <$> ff)
    note: Use flap operator
    rhs: ff ?? x
- warn:
    lhs: fmap f (nonEmpty x)
    rhs: viaNonEmpty f x
- warn:
    lhs: fmap f . nonEmpty
    rhs: viaNonEmpty f
- warn:
    lhs: f <$> nonEmpty x
    rhs: viaNonEmpty f x
- warn:
    lhs: f >>= guard
    rhs: guardM f
- warn:
    lhs: guard =<< f
    rhs: guardM f
- warn:
    lhs: whenM (not <$> x)
    rhs: unlessM x
- warn:
    lhs: unlessM (not <$> x)
    rhs: whenM x
- warn:
    lhs: either (const True) (const False)
    rhs: isLeft
- warn:
    lhs: either (const False) (const True)
    rhs: isRight
- warn:
    lhs: either id (const a)
    rhs: fromLeft a
- warn:
    lhs: either (const b) id
    rhs: fromRight b
- warn:
    lhs: either Just (const Nothing)
    rhs: leftToMaybe
- warn:
    lhs: either (const Nothing) Just
    rhs: rightToMaybe
- warn:
    lhs: maybe (Left l) Right
    rhs: maybeToRight l
- warn:
    lhs: maybe (Right r) Left
    rhs: maybeToLeft r
- warn:
    lhs: (case m of Just x -> f x; Nothing -> pure ()  )
    rhs: whenJust m f
- warn:
    lhs: (case m of Just x -> f x; Nothing -> return ())
    rhs: whenJust m f
- warn:
    lhs: (case m of Just x -> f x; Nothing -> pass     )
    rhs: whenJust m f
- warn:
    lhs: (case m of Nothing -> pure ()  ; Just x -> f x)
    rhs: whenJust m f
- warn:
    lhs: (case m of Nothing -> return (); Just x -> f x)
    rhs: whenJust m f
- warn:
    lhs: (case m of Nothing -> pass     ; Just x -> f x)
    rhs: whenJust m f
- warn:
    lhs: (maybe (pure ())   f m)
    rhs: whenJust m f
- warn:
    lhs: (maybe (return ()) f m)
    rhs: whenJust m f
- warn:
    lhs: (maybe pass        f m)
    rhs: whenJust m f
- warn:
    lhs: (m >>= \a -> whenJust a f)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Just x -> f x; Nothing -> pure ()  )
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Just x -> f x; Nothing -> return ())
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Just x -> f x; Nothing -> pass     )
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Nothing -> pure ()  ; Just x -> f x)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Nothing -> return (); Just x -> f x)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= \case Nothing -> pass     ; Just x -> f x)
    rhs: whenJustM m f
- warn:
    lhs: (maybe (pure ())   f =<< m)
    rhs: whenJustM m f
- warn:
    lhs: (maybe (return ()) f =<< m)
    rhs: whenJustM m f
- warn:
    lhs: (maybe pass        f =<< m)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= maybe (pure ())   f)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= maybe (return ()) f)
    rhs: whenJustM m f
- warn:
    lhs: (m >>= maybe pass        f)
    rhs: whenJustM m f
- warn:
    lhs: (case m of Just _ -> pure ()  ; Nothing -> x)
    rhs: whenNothing_ m x
- warn:
    lhs: (case m of Just _ -> return (); Nothing -> x)
    rhs: whenNothing_ m x
- warn:
    lhs: (case m of Just _ -> pass     ; Nothing -> x)
    rhs: whenNothing_ m x
- warn:
    lhs: (case m of Nothing -> x; Just _ -> pure ()  )
    rhs: whenNothing_ m x
- warn:
    lhs: (case m of Nothing -> x; Just _ -> return ())
    rhs: whenNothing_ m x
- warn:
    lhs: (case m of Nothing -> x; Just _ -> pass     )
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (\_ -> pure ()    ) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (\_ -> return ()  ) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (\_ -> pass       ) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (const (pure ()  )) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (const (return ())) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (maybe x (const (pass     )) m)
    rhs: whenNothing_ m x
- warn:
    lhs: (m >>= \a -> whenNothing_ a x)
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Just _ -> pure ()  ; Nothing -> x)
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Just _ -> return (); Nothing -> x)
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Just _ -> pass     ; Nothing -> x)
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Nothing -> x; Just _ -> pure ()  )
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Nothing -> x; Just _ -> return ())
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= \case Nothing -> x; Just _ -> pass     )
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (\_ -> pure ()    ) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (\_ -> return ()  ) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (\_ -> pass       ) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (const (pure ()  )) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (const (return ())) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (maybe x (const (pass     )) =<< m)
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (\_ -> pure ())    )
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (\_ -> return ())  )
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (\_ -> pass)       )
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (const (pure ())  ))
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (const (return ())))
    rhs: whenNothingM_ m x
- warn:
    lhs: (m >>= maybe x (const (pass)     ))
    rhs: whenNothingM_ m x
- warn:
    lhs: (whenLeft ())
    rhs: whenLeft_
- warn:
    lhs: (case m of Left x -> f x; Right _ -> pure ()  )
    rhs: whenLeft_ m f
- warn:
    lhs: (case m of Left x -> f x; Right _ -> return ())
    rhs: whenLeft_ m f
- warn:
    lhs: (case m of Left x -> f x; Right _ -> pass     )
    rhs: whenLeft_ m f
- warn:
    lhs: (case m of Right _ -> pure ()  ; Left x -> f x)
    rhs: whenLeft_ m f
- warn:
    lhs: (case m of Right _ -> return (); Left x -> f x)
    rhs: whenLeft_ m f
- warn:
    lhs: (case m of Right _ -> pass     ; Left x -> f x)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (\_ -> pure ()    ) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (\_ -> return ()  ) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (\_ -> pass       ) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (const (pure ()  )) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (const (return ())) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (either f (const (pass     )) m)
    rhs: whenLeft_ m f
- warn:
    lhs: (m >>= \a -> whenLeft_ a f)
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Left x -> f x; Right _ -> pure ()  )
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Left x -> f x; Right _ -> return ())
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Left x -> f x; Right _ -> pass     )
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Right _ -> pure ()  ; Left x -> f x)
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Right _ -> return (); Left x -> f x)
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= \case Right _ -> pass     ; Left x -> f x)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (\_ -> pure ()    ) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (\_ -> return ()  ) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (\_ -> pass       ) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (const (pure ()  )) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (const (return ())) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (either f (const (pass     )) =<< m)
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (\_ -> pure ())    )
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (\_ -> return ())  )
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (\_ -> pass)       )
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (const (pure ())  ))
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (const (return ())))
    rhs: whenLeftM_ m f
- warn:
    lhs: (m >>= either f (const (pass)     ))
    rhs: whenLeftM_ m f
- warn:
    lhs: (whenRight ())
    rhs: whenRight_
- warn:
    lhs: (case m of Right x -> f x; Left _ -> pure ()  )
    rhs: whenRight_ m f
- warn:
    lhs: (case m of Right x -> f x; Left _ -> return ())
    rhs: whenRight_ m f
- warn:
    lhs: (case m of Right x -> f x; Left _ -> pass     )
    rhs: whenRight_ m f
- warn:
    lhs: (case m of Left _ -> pure ()  ; Right x -> f x)
    rhs: whenRight_ m f
- warn:
    lhs: (case m of Left _ -> return (); Right x -> f x)
    rhs: whenRight_ m f
- warn:
    lhs: (case m of Left _ -> pass     ; Right x -> f x)
    rhs: whenRight_ m f
- warn:
    lhs: (either (\_ -> pure ()    ) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (either (\_ -> return ()  ) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (either (\_ -> pass       ) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (either (const (pure ()  )) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (either (const (return ())) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (either (const (pass     )) f m)
    rhs: whenRight_ m f
- warn:
    lhs: (m >>= \a -> whenRight_ a f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Right x -> f x; Left _ -> pure ()  )
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Right x -> f x; Left _ -> return ())
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Right x -> f x; Left _ -> pass     )
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Left _ -> pure ()  ; Right x -> f x)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Left _ -> return (); Right x -> f x)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= \case Left _ -> pass     ; Right x -> f x)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (\_ -> pure ()    ) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (\_ -> return ()  ) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (\_ -> pass       ) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (const (pure ()  )) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (const (return ())) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (either (const (pass     )) f =<< m)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (\_ -> pure ())     f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (\_ -> return ())   f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (\_ -> pass)        f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (const (pure ())  ) f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (const (return ())) f)
    rhs: whenRightM_ m f
- warn:
    lhs: (m >>= either (const (pass)     ) f)
    rhs: whenRightM_ m f
- warn:
    lhs: (case m of [] -> return (); (x:xs) -> f (x :| xs))
    rhs: whenNotNull m f
- warn:
    lhs: (case m of [] -> pure ()  ; (x:xs) -> f (x :| xs))
    rhs: whenNotNull m f
- warn:
    lhs: (case m of [] -> pass     ; (x:xs) -> f (x :| xs))
    rhs: whenNotNull m f
- warn:
    lhs: (case m of (x:xs) -> f (x :| xs); [] -> return ())
    rhs: whenNotNull m f
- warn:
    lhs: (case m of (x:xs) -> f (x :| xs); [] -> pure ()  )
    rhs: whenNotNull m f
- warn:
    lhs: (case m of (x:xs) -> f (x :| xs); [] -> pass     )
    rhs: whenNotNull m f
- warn:
    lhs: (m >>= \case [] -> pass     ; (x:xs) -> f (x :| xs))
    rhs: whenNotNullM m f
- warn:
    lhs: (m >>= \case [] -> pure ()  ; (x:xs) -> f (x :| xs))
    rhs: whenNotNullM m f
- warn:
    lhs: (m >>= \case [] -> return (); (x:xs) -> f (x :| xs))
    rhs: whenNotNullM m f
- warn:
    lhs: (m >>= \case (x:xs) -> f (x :| xs); [] -> pass     )
    rhs: whenNotNullM m f
- warn:
    lhs: (m >>= \case (x:xs) -> f (x :| xs); [] -> pure ()  )
    rhs: whenNotNullM m f
- warn:
    lhs: (m >>= \case (x:xs) -> f (x :| xs); [] -> return ())
    rhs: whenNotNullM m f
- warn:
    lhs: mapMaybe leftToMaybe
    rhs: lefts
- warn:
    lhs: mapMaybe rightToMaybe
    rhs: rights
- warn:
    lhs: flip runReaderT
    rhs: usingReaderT
- warn:
    lhs: flip runReader
    rhs: usingReader
- warn:
    lhs: flip runStateT
    rhs: usingStateT
- warn:
    lhs: flip runState
    rhs: usingState
- warn:
    lhs: fst <$> usingStateT s st
    rhs: evaluatingStateT s st
- warn:
    lhs: fst (usingState s st)
    rhs: evaluatingState s st
- warn:
    lhs: snd <$> usingStateT s st
    rhs: executingStateT s st
- warn:
    lhs: snd (usingState s st)
    rhs: executingState s st
- warn:
    lhs: fromMaybe mempty
    rhs: maybeToMonoid
- warn:
    lhs: ! 'm ?: mempty'
    rhs: maybeToMonoid m
- warn:
    lhs: Data.Map.toAscList (Data.Map.fromList x)
    rhs: sortWith fst x
- warn:
    lhs: Data.Map.toDescList (Data.Map.fromList x)
    rhs: sortWith (Down . fst) x
- warn:
    lhs: Data.Set.toList (Data.Set.fromList l)
    rhs: sortNub l
- warn:
    lhs: Data.Set.assocs (Data.Set.fromList l)
    rhs: sortNub l
- warn:
    lhs: Data.Set.toAscList (Data.Set.fromList l)
    rhs: sortNub l
- warn:
    lhs: Data.HashSet.toList (Data.HashSet.fromList l)
    rhs: unstableNub l
- warn:
    lhs: nub
    note: ! '''nub'' is O(n^2), ''ordNub'' is O(n log n)'
    rhs: ordNub
- warn:
    lhs: sortBy (comparing f)
    note: If the function you are using for 'comparing' is slow, use 'sortOn' instead
      of 'sortWith', because 'sortOn' caches applications the function and 'sortWith'
      doesn't.
    rhs: sortWith f
- warn:
    lhs: sortOn fst
    note: ! '''sortWith'' will be faster here because it doesn''t do caching'
    rhs: sortWith fst
- warn:
    lhs: sortOn snd
    note: ! '''sortWith'' will be faster here because it doesn''t do caching'
    rhs: sortWith snd
- warn:
    lhs: sortOn (Down . fst)
    note: ! '''sortWith'' will be faster here because it doesn''t do caching'
    rhs: sortWith (Down . fst)
- warn:
    lhs: sortOn (Down . snd)
    note: ! '''sortWith'' will be faster here because it doesn''t do caching'
    rhs: sortWith (Down . snd)
- warn:
    lhs: Data.Text.IO.putStr
    rhs: putText
- warn:
    lhs: Data.Text.IO.putStrLn
    rhs: putTextLn
- warn:
    lhs: Data.Text.Lazy.IO.putStr
    rhs: putLText
- warn:
    lhs: Data.Text.Lazy.IO.putStrLn
    rhs: putLTextLn
- warn:
    lhs: Data.ByteString.Char8.putStr
    rhs: putBS
- warn:
    lhs: Data.ByteString.Char8.putStrLn
    rhs: putBSLn
- warn:
    lhs: Data.ByteString.Lazy.Char8.putStr
    rhs: putLBS
- warn:
    lhs: Data.ByteString.Lazy.Char8.putStrLn
    rhs: putLBSLn
- warn:
    lhs: Data.Text.Lazy.Text
    rhs: LText
- warn:
    lhs: Data.ByteString.Lazy.ByteString
    rhs: LByteString
- warn:
    lhs: Data.ByteString.UTF8.fromString
    rhs: encodeUtf8
- warn:
    lhs: Data.ByteString.UTF8.toString
    rhs: decodeUtf8
- warn:
    lhs: Data.Text.Encoding.encodeUtf8
    rhs: encodeUtf8
- warn:
    lhs: Data.Text.Encoding.decodeUtf8
    rhs: decodeUtf8
- warn:
    lhs: Data.ByteString.Lazy.toStrict (encodeUtf8 x)
    rhs: encodeUtf8 x
- warn:
    lhs: toStrict (encodeUtf8 x)
    rhs: encodeUtf8 x
- warn:
    lhs: decodeUtf8 (Data.ByteString.Lazy.fromStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: decodeUtf8 (fromStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: Data.ByteString.Lazy.UTF8.fromString
    rhs: encodeUtf8
- warn:
    lhs: Data.ByteString.Lazy.UTF8.toString
    rhs: decodeUtf8
- warn:
    lhs: Data.ByteString.Lazy.fromStrict (Data.Text.Encoding.encodeUtf8 x)
    rhs: encodeUtf8 x
- warn:
    lhs: Data.ByteString.Lazy.fromStrict (encodeUtf8 x)
    rhs: encodeUtf8 x
- warn:
    lhs: Data.Text.Encoding.decodeUtf8 (Data.ByteString.Lazy.toStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: Data.Text.Encoding.decodeUtf8 (toStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: decodeUtf8 (Data.ByteString.Lazy.toStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: decodeUtf8 (toStrict x)
    rhs: decodeUtf8 x
- warn:
    lhs: Data.Text.pack
    rhs: toText
- warn:
    lhs: Data.Text.unpack
    rhs: toString
- warn:
    lhs: Data.Text.Lazy.pack
    rhs: toLText
- warn:
    lhs: Data.Text.Lazy.unpack
    rhs: toString
- warn:
    lhs: Data.Text.Lazy.toStrict
    rhs: toText
- warn:
    lhs: Data.Text.Lazy.fromStrict
    rhs: toLText
- warn:
    lhs: Data.Text.pack (show x)
    rhs: show x
- warn:
    lhs: Data.Text.Lazy.pack (show x)
    rhs: show x
- warn:
    lhs: Data.ByteString.Lazy.fromStrict
    rhs: fromStrict
- warn:
    lhs: Data.ByteString.Lazy.toStrict
    rhs: toStrict
- warn:
    lhs: Data.Text.Lazy.fromStrict
    rhs: fromStrict
- warn:
    lhs: Data.Text.Lazy.toStrict
    rhs: toStrict
- warn:
    lhs: Control.Applicative.Alternative
    note: Function 'Alternative' is already exported from Relude
    name: Use 'Alternative' from Relude
    rhs: Alternative
- warn:
    lhs: Control.Applicative.empty
    note: Function 'empty' is already exported from Relude
    name: Use 'empty' from Relude
    rhs: empty
- warn:
    lhs: (Control.Applicative.<|>)
    note: Operator '(<|>)' is already exported from Relude
    name: Use '<|>' from Relude
    rhs: (<|>)
- warn:
    lhs: Control.Applicative.some
    note: Function 'some' is already exported from Relude
    name: Use 'some' from Relude
    rhs: some
- warn:
    lhs: Control.Applicative.many
    note: Function 'many' is already exported from Relude
    name: Use 'many' from Relude
    rhs: many
- warn:
    lhs: Control.Applicative.Const
    note: Function 'Const' is already exported from Relude
    name: Use 'Const' from Relude
    rhs: Const
- warn:
    lhs: Control.Applicative.getConst
    note: Function 'getConst' is already exported from Relude
    name: Use 'getConst' from Relude
    rhs: getConst
- warn:
    lhs: Control.Applicative.ZipList
    note: Function 'ZipList' is already exported from Relude
    name: Use 'ZipList' from Relude
    rhs: ZipList
- warn:
    lhs: Control.Applicative.getZipList
    note: Function 'getZipList' is already exported from Relude
    name: Use 'getZipList' from Relude
    rhs: getZipList
- warn:
    lhs: Control.Applicative.liftA2
    note: Function 'liftA2' is already exported from Relude
    name: Use 'liftA2' from Relude
    rhs: liftA2
- warn:
    lhs: Control.Applicative.liftA3
    note: Function 'liftA3' is already exported from Relude
    name: Use 'liftA3' from Relude
    rhs: liftA3
- warn:
    lhs: Control.Applicative.optional
    note: Function 'optional' is already exported from Relude
    name: Use 'optional' from Relude
    rhs: optional
- warn:
    lhs: (Control.Applicative.<**>)
    note: Operator '(<**>)' is already exported from Relude
    name: Use '<**>' from Relude
    rhs: (<**>)
- warn:
    lhs: Data.Bits.xor
    note: Function 'xor' is already exported from Relude
    name: Use 'xor' from Relude
    rhs: xor
- warn:
    lhs: Data.Char.chr
    note: Function 'chr' is already exported from Relude
    name: Use 'chr' from Relude
    rhs: chr
- warn:
    lhs: Data.Int.Int8
    note: Function 'Int8' is already exported from Relude
    name: Use 'Int8' from Relude
    rhs: Int8
- warn:
    lhs: Data.Int.Int16
    note: Function 'Int16' is already exported from Relude
    name: Use 'Int16' from Relude
    rhs: Int16
- warn:
    lhs: Data.Int.Int32
    note: Function 'Int32' is already exported from Relude
    name: Use 'Int32' from Relude
    rhs: Int32
- warn:
    lhs: Data.Int.Int64
    note: Function 'Int64' is already exported from Relude
    name: Use 'Int64' from Relude
    rhs: Int64
- warn:
    lhs: Data.Word.Word8
    note: Function 'Word8' is already exported from Relude
    name: Use 'Word8' from Relude
    rhs: Word8
- warn:
    lhs: Data.Word.Word16
    note: Function 'Word16' is already exported from Relude
    name: Use 'Word16' from Relude
    rhs: Word16
- warn:
    lhs: Data.Word.Word32
    note: Function 'Word32' is already exported from Relude
    name: Use 'Word32' from Relude
    rhs: Word32
- warn:
    lhs: Data.Word.Word64
    note: Function 'Word64' is already exported from Relude
    name: Use 'Word64' from Relude
    rhs: Word64
- warn:
    lhs: Data.Word.byteSwap16
    note: Function 'byteSwap16' is already exported from Relude
    name: Use 'byteSwap16' from Relude
    rhs: byteSwap16
- warn:
    lhs: Data.Word.byteSwap32
    note: Function 'byteSwap32' is already exported from Relude
    name: Use 'byteSwap32' from Relude
    rhs: byteSwap32
- warn:
    lhs: Data.Word.byteSwap64
    note: Function 'byteSwap64' is already exported from Relude
    name: Use 'byteSwap64' from Relude
    rhs: byteSwap64
- warn:
    lhs: Numeric.Natural.Natural
    note: Function 'Natural' is already exported from Relude
    name: Use 'Natural' from Relude
    rhs: Natural
- warn:
    lhs: System.IO.Handle
    note: Function 'Handle' is already exported from Relude
    name: Use 'Handle' from Relude
    rhs: Handle
- warn:
    lhs: System.IO.IOMode
    note: Function 'IOMode' is already exported from Relude
    name: Use 'IOMode' from Relude
    rhs: IOMode
- warn:
    lhs: System.IO.ReadMode
    note: Function 'ReadMode' is already exported from Relude
    name: Use 'ReadMode' from Relude
    rhs: ReadMode
- warn:
    lhs: System.IO.WriteMode
    note: Function 'WriteMode' is already exported from Relude
    name: Use 'WriteMode' from Relude
    rhs: WriteMode
- warn:
    lhs: System.IO.AppendMode
    note: Function 'AppendMode' is already exported from Relude
    name: Use 'AppendMode' from Relude
    rhs: AppendMode
- warn:
    lhs: System.IO.ReadWriteMode
    note: Function 'ReadWriteMode' is already exported from Relude
    name: Use 'ReadWriteMode' from Relude
    rhs: ReadWriteMode
- warn:
    lhs: System.IO.stderr
    note: Function 'stderr' is already exported from Relude
    name: Use 'stderr' from Relude
    rhs: stderr
- warn:
    lhs: System.IO.stdin
    note: Function 'stdin' is already exported from Relude
    name: Use 'stdin' from Relude
    rhs: stdin
- warn:
    lhs: System.IO.stdout
    note: Function 'stdout' is already exported from Relude
    name: Use 'stdout' from Relude
    rhs: stdout
- warn:
    lhs: System.IO.withFile
    note: Function 'withFile' is already exported from Relude
    name: Use 'withFile' from Relude
    rhs: withFile
- warn:
    lhs: Data.Ord.Down
    note: Function 'Down' is already exported from Relude
    name: Use 'Down' from Relude
    rhs: Down
- warn:
    lhs: Data.Ord.comparing
    note: Function 'comparing' is already exported from Relude
    name: Use 'comparing' from Relude
    rhs: comparing
- warn:
    lhs: Data.Coerce.Coercible
    note: Function 'Coercible' is already exported from Relude
    name: Use 'Coercible' from Relude
    rhs: Coercible
- warn:
    lhs: Data.Coerce.coerce
    note: Function 'coerce' is already exported from Relude
    name: Use 'coerce' from Relude
    rhs: coerce
- warn:
    lhs: Data.Kind.Constraint
    note: Function 'Constraint' is already exported from Relude
    name: Use 'Constraint' from Relude
    rhs: Constraint
- warn:
    lhs: Data.Kind.Type
    note: Function 'Type' is already exported from Relude
    name: Use 'Type' from Relude
    rhs: Type
- warn:
    lhs: Data.Typeable.Typeable
    note: Function 'Typeable' is already exported from Relude
    name: Use 'Typeable' from Relude
    rhs: Typeable
- warn:
    lhs: Data.Proxy.Proxy
    note: Function 'Proxy' is already exported from Relude
    name: Use 'Proxy' from Relude
    rhs: Proxy
- warn:
    lhs: Data.Typeable.Typeable
    note: Function 'Typeable' is already exported from Relude
    name: Use 'Typeable' from Relude
    rhs: Typeable
- warn:
    lhs: Data.Void.Void
    note: Function 'Void' is already exported from Relude
    name: Use 'Void' from Relude
    rhs: Void
- warn:
    lhs: Data.Void.absurd
    note: Function 'absurd' is already exported from Relude
    name: Use 'absurd' from Relude
    rhs: absurd
- warn:
    lhs: Data.Void.vacuous
    note: Function 'vacuous' is already exported from Relude
    name: Use 'vacuous' from Relude
    rhs: vacuous
- warn:
    lhs: Data.Base.maxInt
    note: Function 'maxInt' is already exported from Relude
    name: Use 'maxInt' from Relude
    rhs: maxInt
- warn:
    lhs: Data.Base.minInt
    note: Function 'minInt' is already exported from Relude
    name: Use 'minInt' from Relude
    rhs: minInt
- warn:
    lhs: Data.Base.ord
    note: Function 'ord' is already exported from Relude
    name: Use 'ord' from Relude
    rhs: ord
- warn:
    lhs: GHC.Enum.boundedEnumFrom
    note: Function 'boundedEnumFrom' is already exported from Relude
    name: Use 'boundedEnumFrom' from Relude
    rhs: boundedEnumFrom
- warn:
    lhs: GHC.Enum.boundedEnumFromThen
    note: Function 'boundedEnumFromThen' is already exported from Relude
    name: Use 'boundedEnumFromThen' from Relude
    rhs: boundedEnumFromThen
- warn:
    lhs: GHC.Generics.Generic
    note: Function 'Generic' is already exported from Relude
    name: Use 'Generic' from Relude
    rhs: Generic
- warn:
    lhs: GHC.Real.Ratio
    note: Function 'Ratio' is already exported from Relude
    name: Use 'Ratio' from Relude
    rhs: Ratio
- warn:
    lhs: GHC.Real.Rational
    note: Function 'Rational' is already exported from Relude
    name: Use 'Rational' from Relude
    rhs: Rational
- warn:
    lhs: GHC.Real.denominator
    note: Function 'denominator' is already exported from Relude
    name: Use 'denominator' from Relude
    rhs: denominator
- warn:
    lhs: GHC.Real.numerator
    note: Function 'numerator' is already exported from Relude
    name: Use 'numerator' from Relude
    rhs: numerator
- warn:
    lhs: GHC.TypeNats.CmpNat
    note: Function 'CmpNat' is already exported from Relude
    name: Use 'CmpNat' from Relude
    rhs: CmpNat
- warn:
    lhs: GHC.TypeNats.KnownNat
    note: Function 'KnownNat' is already exported from Relude
    name: Use 'KnownNat' from Relude
    rhs: KnownNat
- warn:
    lhs: GHC.TypeNats.Nat
    note: Function 'Nat' is already exported from Relude
    name: Use 'Nat' from Relude
    rhs: Nat
- warn:
    lhs: GHC.TypeNats.SomeNat
    note: Function 'SomeNat' is already exported from Relude
    name: Use 'SomeNat' from Relude
    rhs: SomeNat
- warn:
    lhs: GHC.TypeNats.natVal
    note: Function 'natVal' is already exported from Relude
    name: Use 'natVal' from Relude
    rhs: natVal
- warn:
    lhs: GHC.TypeNats.someNatVal
    note: Function 'someNatVal' is already exported from Relude
    name: Use 'someNatVal' from Relude
    rhs: someNatVal
- warn:
    lhs: GHC.TypeLits.CmpNat
    note: Function 'CmpNat' is already exported from Relude
    name: Use 'CmpNat' from Relude
    rhs: CmpNat
- warn:
    lhs: GHC.TypeLits.KnownNat
    note: Function 'KnownNat' is already exported from Relude
    name: Use 'KnownNat' from Relude
    rhs: KnownNat
- warn:
    lhs: GHC.TypeLits.Nat
    note: Function 'Nat' is already exported from Relude
    name: Use 'Nat' from Relude
    rhs: Nat
- warn:
    lhs: GHC.TypeLits.SomeNat
    note: Function 'SomeNat' is already exported from Relude
    name: Use 'SomeNat' from Relude
    rhs: SomeNat
- warn:
    lhs: GHC.TypeLits.natVal
    note: Function 'natVal' is already exported from Relude
    name: Use 'natVal' from Relude
    rhs: natVal
- warn:
    lhs: GHC.TypeLits.someNatVal
    note: Function 'someNatVal' is already exported from Relude
    name: Use 'someNatVal' from Relude
    rhs: someNatVal
- warn:
    lhs: GHC.ExecutionStack.getStackTrace
    note: Function 'getStackTrace' is already exported from Relude
    name: Use 'getStackTrace' from Relude
    rhs: getStackTrace
- warn:
    lhs: GHC.ExecutionStack.showStackTrace
    note: Function 'showStackTrace' is already exported from Relude
    name: Use 'showStackTrace' from Relude
    rhs: showStackTrace
- warn:
    lhs: GHC.OverloadedLabels.IsLabel
    note: Function 'IsLabel' is already exported from Relude
    name: Use 'IsLabel' from Relude
    rhs: IsLabel
- warn:
    lhs: GHC.OverloadedLabels.fromLabel
    note: Function 'fromLabel' is already exported from Relude
    name: Use 'fromLabel' from Relude
    rhs: fromLabel
- warn:
    lhs: GHC.Stack.CallStack
    note: Function 'CallStack' is already exported from Relude
    name: Use 'CallStack' from Relude
    rhs: CallStack
- warn:
    lhs: GHC.Stack.HasCallStack
    note: Function 'HasCallStack' is already exported from Relude
    name: Use 'HasCallStack' from Relude
    rhs: HasCallStack
- warn:
    lhs: GHC.Stack.callStack
    note: Function 'callStack' is already exported from Relude
    name: Use 'callStack' from Relude
    rhs: callStack
- warn:
    lhs: GHC.Stack.currentCallStack
    note: Function 'currentCallStack' is already exported from Relude
    name: Use 'currentCallStack' from Relude
    rhs: currentCallStack
- warn:
    lhs: GHC.Stack.getCallStack
    note: Function 'getCallStack' is already exported from Relude
    name: Use 'getCallStack' from Relude
    rhs: getCallStack
- warn:
    lhs: GHC.Stack.prettyCallStack
    note: Function 'prettyCallStack' is already exported from Relude
    name: Use 'prettyCallStack' from Relude
    rhs: prettyCallStack
- warn:
    lhs: GHC.Stack.prettySrcLoc
    note: Function 'prettySrcLoc' is already exported from Relude
    name: Use 'prettySrcLoc' from Relude
    rhs: prettySrcLoc
- warn:
    lhs: GHC.Stack.withFrozenCallStack
    note: Function 'withFrozenCallStack' is already exported from Relude
    name: Use 'withFrozenCallStack' from Relude
    rhs: withFrozenCallStack
- warn:
    lhs: Control.Monad.guard
    note: Function 'guard' is already exported from Relude
    name: Use 'guard' from Relude
    rhs: guard
- warn:
    lhs: Control.Monad.unless
    note: Function 'unless' is already exported from Relude
    name: Use 'unless' from Relude
    rhs: unless
- warn:
    lhs: Control.Monad.when
    note: Function 'when' is already exported from Relude
    name: Use 'when' from Relude
    rhs: when
- warn:
    lhs: Data.Bool.bool
    note: Function 'bool' is already exported from Relude
    name: Use 'bool' from Relude
    rhs: bool
- warn:
    lhs: Data.Hashable.Hashable
    note: Function 'Hashable' is already exported from Relude
    name: Use 'Hashable' from Relude
    rhs: Hashable
- warn:
    lhs: Data.Hashable.hashWithSalt
    note: Function 'hashWithSalt' is already exported from Relude
    name: Use 'hashWithSalt' from Relude
    rhs: hashWithSalt
- warn:
    lhs: Data.HashMap.Strict.HashMap
    note: Function 'HashMap' is already exported from Relude
    name: Use 'HashMap' from Relude
    rhs: HashMap
- warn:
    lhs: Data.HashSet.HashSet
    note: Function 'HashSet' is already exported from Relude
    name: Use 'HashSet' from Relude
    rhs: HashSet
- warn:
    lhs: Data.IntMap.Strict.IntMap
    note: Function 'IntMap' is already exported from Relude
    name: Use 'IntMap' from Relude
    rhs: IntMap
- warn:
    lhs: Data.IntSet.IntSet
    note: Function 'IntSet' is already exported from Relude
    name: Use 'IntSet' from Relude
    rhs: IntSet
- warn:
    lhs: Data.Map.Strict.Map
    note: Function 'Map' is already exported from Relude
    name: Use 'Map' from Relude
    rhs: Map
- warn:
    lhs: Data.Sequence.Sequence
    note: Function 'Sequence' is already exported from Relude
    name: Use 'Sequence' from Relude
    rhs: Sequence
- warn:
    lhs: Data.Set.Set
    note: Function 'Set' is already exported from Relude
    name: Use 'Set' from Relude
    rhs: Set
- warn:
    lhs: Data.Tuple.swap
    note: Function 'swap' is already exported from Relude
    name: Use 'swap' from Relude
    rhs: swap
- warn:
    lhs: Data.Vector.Vector
    note: Function 'Vector' is already exported from Relude
    name: Use 'Vector' from Relude
    rhs: Vector
- warn:
    lhs: GHC.Exts.IsList
    note: Function 'IsList' is already exported from Relude
    name: Use 'IsList' from Relude
    rhs: IsList
- warn:
    lhs: GHC.Exts.fromList
    note: Function 'fromList' is already exported from Relude
    name: Use 'fromList' from Relude
    rhs: fromList
- warn:
    lhs: GHC.Exts.fromListN
    note: Function 'fromListN' is already exported from Relude
    name: Use 'fromListN' from Relude
    rhs: fromListN
- warn:
    lhs: Debug.Trace.trace
    note: Function 'trace' is already exported from Relude
    name: Use 'trace' from Relude
    rhs: trace
- warn:
    lhs: Debug.Trace.traceShow
    note: Function 'traceShow' is already exported from Relude
    name: Use 'traceShow' from Relude
    rhs: traceShow
- warn:
    lhs: Debug.Trace.traceShowId
    note: Function 'traceShowId' is already exported from Relude
    name: Use 'traceShowId' from Relude
    rhs: traceShowId
- warn:
    lhs: Debug.Trace.traceShowM
    note: Function 'traceShowM' is already exported from Relude
    name: Use 'traceShowM' from Relude
    rhs: traceShowM
- warn:
    lhs: Debug.Trace.traceM
    note: Function 'traceM' is already exported from Relude
    name: Use 'traceM' from Relude
    rhs: traceM
- warn:
    lhs: Debug.Trace.traceId
    note: Function 'traceId' is already exported from Relude
    name: Use 'traceId' from Relude
    rhs: traceId
- warn:
    lhs: Control.DeepSeq.NFData
    note: Function 'NFData' is already exported from Relude
    name: Use 'NFData' from Relude
    rhs: NFData
- warn:
    lhs: Control.DeepSeq.rnf
    note: Function 'rnf' is already exported from Relude
    name: Use 'rnf' from Relude
    rhs: rnf
- warn:
    lhs: Control.DeepSeq.deepseq
    note: Function 'deepseq' is already exported from Relude
    name: Use 'deepseq' from Relude
    rhs: deepseq
- warn:
    lhs: Control.DeepSeq.force
    note: Function 'force' is already exported from Relude
    name: Use 'force' from Relude
    rhs: force
- warn:
    lhs: (Control.DeepSeq.$!!)
    note: Operator '($!!)' is already exported from Relude
    name: Use '$!!' from Relude
    rhs: ($!!)
- warn:
    lhs: Control.Exception.Exception
    note: Function 'Exception' is already exported from Relude
    name: Use 'Exception' from Relude
    rhs: Exception
- warn:
    lhs: Control.Exception.SomeException
    note: Function 'SomeException' is already exported from Relude
    name: Use 'SomeException' from Relude
    rhs: SomeException
- warn:
    lhs: Control.Exception.toException
    note: Function 'toException' is already exported from Relude
    name: Use 'toException' from Relude
    rhs: toException
- warn:
    lhs: Control.Exception.fromException
    note: Function 'fromException' is already exported from Relude
    name: Use 'fromException' from Relude
    rhs: fromException
- warn:
    lhs: Control.Exception.displayException
    note: Function 'displayException' is already exported from Relude
    name: Use 'displayException' from Relude
    rhs: displayException
- warn:
    lhs: Data.Foldable.asum
    note: Function 'asum' is already exported from Relude
    name: Use 'asum' from Relude
    rhs: asum
- warn:
    lhs: Data.Foldable.find
    note: Function 'find' is already exported from Relude
    name: Use 'find' from Relude
    rhs: find
- warn:
    lhs: Data.Foldable.find
    note: Function 'find' is already exported from Relude
    name: Use 'find' from Relude
    rhs: find
- warn:
    lhs: Data.Foldable.fold
    note: Function 'fold' is already exported from Relude
    name: Use 'fold' from Relude
    rhs: fold
- warn:
    lhs: Data.Foldable.foldl'
    note: Function 'foldl'' is already exported from Relude
    name: Use 'foldl'' from Relude
    rhs: foldl'
- warn:
    lhs: Data.Foldable.foldrM
    note: Function 'foldrM' is already exported from Relude
    name: Use 'foldrM' from Relude
    rhs: foldrM
- warn:
    lhs: Data.Foldable.forM_
    note: Function 'forM_' is already exported from Relude
    name: Use 'forM_' from Relude
    rhs: forM_
- warn:
    lhs: Data.Foldable.for_
    note: Function 'for_' is already exported from Relude
    name: Use 'for_' from Relude
    rhs: for_
- warn:
    lhs: Data.Foldable.sequenceA_
    note: Function 'sequenceA_' is already exported from Relude
    name: Use 'sequenceA_' from Relude
    rhs: sequenceA_
- warn:
    lhs: Data.Foldable.toList
    note: Function 'toList' is already exported from Relude
    name: Use 'toList' from Relude
    rhs: toList
- warn:
    lhs: Data.Foldable.traverse_
    note: Function 'traverse_' is already exported from Relude
    name: Use 'traverse_' from Relude
    rhs: traverse_
- warn:
    lhs: Data.Traversable.forM
    note: Function 'forM' is already exported from Relude
    name: Use 'forM' from Relude
    rhs: forM
- warn:
    lhs: Data.Traversable.mapAccumL
    note: Function 'mapAccumL' is already exported from Relude
    name: Use 'mapAccumL' from Relude
    rhs: mapAccumL
- warn:
    lhs: Data.Traversable.mapAccumR
    note: Function 'mapAccumR' is already exported from Relude
    name: Use 'mapAccumR' from Relude
    rhs: mapAccumR
- warn:
    lhs: (Control.Category.>>>)
    note: Operator '(>>>)' is already exported from Relude
    name: Use '>>>' from Relude
    rhs: (>>>)
- warn:
    lhs: (Control.Category.<<<)
    note: Operator '(<<<)' is already exported from Relude
    name: Use '<<<' from Relude
    rhs: (<<<)
- warn:
    lhs: Data.Function.fix
    note: Function 'fix' is already exported from Relude
    name: Use 'fix' from Relude
    rhs: fix
- warn:
    lhs: Data.Function.on
    note: Function 'on' is already exported from Relude
    name: Use 'on' from Relude
    rhs: 'on'
- warn:
    lhs: (Control.Arrow.&&&)
    note: Operator '(&&&)' is already exported from Relude
    name: Use '&&&' from Relude
    rhs: (&&&)
- warn:
    lhs: Data.Bifunctor.Bifunctor
    note: Function 'Bifunctor' is already exported from Relude
    name: Use 'Bifunctor' from Relude
    rhs: Bifunctor
- warn:
    lhs: Data.Bifunctor.bimap
    note: Function 'bimap' is already exported from Relude
    name: Use 'bimap' from Relude
    rhs: bimap
- warn:
    lhs: Data.Bifunctor.first
    note: Function 'first' is already exported from Relude
    name: Use 'first' from Relude
    rhs: first
- warn:
    lhs: Data.Bifunctor.second
    note: Function 'second' is already exported from Relude
    name: Use 'second' from Relude
    rhs: second
- warn:
    lhs: Data.Functor.void
    note: Function 'void' is already exported from Relude
    name: Use 'void' from Relude
    rhs: void
- warn:
    lhs: (Data.Functor.$>)
    note: Operator '($>)' is already exported from Relude
    name: Use '$>' from Relude
    rhs: ($>)
- warn:
    lhs: (Data.Functor.<&>)
    note: Operator '(<&>)' is already exported from Relude
    name: Use '<&>' from Relude
    rhs: (<&>)
- warn:
    lhs: Data.Functor.Compose.Compose
    note: Function 'Compose' is already exported from Relude
    name: Use 'Compose' from Relude
    rhs: Compose
- warn:
    lhs: Data.Functor.Compose.getCompose
    note: Function 'getCompose' is already exported from Relude
    name: Use 'getCompose' from Relude
    rhs: getCompose
- warn:
    lhs: Data.Functor.Identity.Identity
    note: Function 'Identity' is already exported from Relude
    name: Use 'Identity' from Relude
    rhs: Identity
- warn:
    lhs: Data.Functor.Identity.runIdentity
    note: Function 'runIdentity' is already exported from Relude
    name: Use 'runIdentity' from Relude
    rhs: runIdentity
- warn:
    lhs: Control.Concurrent.MVar.MVar
    note: Function 'MVar' is already exported from Relude
    name: Use 'MVar' from Relude
    rhs: MVar
- warn:
    lhs: Control.Concurrent.MVar.newEmptyMVar
    note: Function 'newEmptyMVar' is already exported from Relude
    name: Use 'newEmptyMVar' from Relude
    rhs: newEmptyMVar
- warn:
    lhs: Control.Concurrent.MVar.newMVar
    note: Function 'newMVar' is already exported from Relude
    name: Use 'newMVar' from Relude
    rhs: newMVar
- warn:
    lhs: Control.Concurrent.MVar.putMVar
    note: Function 'putMVar' is already exported from Relude
    name: Use 'putMVar' from Relude
    rhs: putMVar
- warn:
    lhs: Control.Concurrent.MVar.readMVar
    note: Function 'readMVar' is already exported from Relude
    name: Use 'readMVar' from Relude
    rhs: readMVar
- warn:
    lhs: Control.Concurrent.MVar.swapMVar
    note: Function 'swapMVar' is already exported from Relude
    name: Use 'swapMVar' from Relude
    rhs: swapMVar
- warn:
    lhs: Control.Concurrent.MVar.takeMVar
    note: Function 'takeMVar' is already exported from Relude
    name: Use 'takeMVar' from Relude
    rhs: takeMVar
- warn:
    lhs: Control.Concurrent.MVar.tryPutMVar
    note: Function 'tryPutMVar' is already exported from Relude
    name: Use 'tryPutMVar' from Relude
    rhs: tryPutMVar
- warn:
    lhs: Control.Concurrent.MVar.tryReadMVar
    note: Function 'tryReadMVar' is already exported from Relude
    name: Use 'tryReadMVar' from Relude
    rhs: tryReadMVar
- warn:
    lhs: Control.Concurrent.MVar.tryTakeMVar
    note: Function 'tryTakeMVar' is already exported from Relude
    name: Use 'tryTakeMVar' from Relude
    rhs: tryTakeMVar
- warn:
    lhs: Control.Monad.STM.STM
    note: Function 'STM' is already exported from Relude
    name: Use 'STM' from Relude
    rhs: STM
- warn:
    lhs: Control.Monad.STM.atomically
    note: Function 'atomically' is already exported from Relude
    name: Use 'atomically' from Relude
    rhs: atomically
- warn:
    lhs: Control.Concurrent.STM.TVar.TVar
    note: Function 'TVar' is already exported from Relude
    name: Use 'TVar' from Relude
    rhs: TVar
- warn:
    lhs: Control.Concurrent.STM.TVar.newTVarIO
    note: Function 'newTVarIO' is already exported from Relude
    name: Use 'newTVarIO' from Relude
    rhs: newTVarIO
- warn:
    lhs: Control.Concurrent.STM.TVar.readTVarIO
    note: Function 'readTVarIO' is already exported from Relude
    name: Use 'readTVarIO' from Relude
    rhs: readTVarIO
- warn:
    lhs: Control.Concurrent.STM.TVar.modifyTVar'
    note: Function 'modifyTVar'' is already exported from Relude
    name: Use 'modifyTVar'' from Relude
    rhs: modifyTVar'
- warn:
    lhs: Control.Concurrent.STM.TVar.newTVar
    note: Function 'newTVar' is already exported from Relude
    name: Use 'newTVar' from Relude
    rhs: newTVar
- warn:
    lhs: Control.Concurrent.STM.TVar.readTVar
    note: Function 'readTVar' is already exported from Relude
    name: Use 'readTVar' from Relude
    rhs: readTVar
- warn:
    lhs: Control.Concurrent.STM.TVar.writeTVar
    note: Function 'writeTVar' is already exported from Relude
    name: Use 'writeTVar' from Relude
    rhs: writeTVar
- warn:
    lhs: Data.Text.IO.appendFile
    note: Function 'appendFile' is already exported from Relude
    name: Use 'appendFile' from Relude
    rhs: appendFile
- warn:
    lhs: Data.Text.IO.getLine
    note: Function 'getLine' is already exported from Relude
    name: Use 'getLine' from Relude
    rhs: getLine
- warn:
    lhs: Data.Text.IO.readFile
    note: Function 'readFile' is already exported from Relude
    name: Use 'readFile' from Relude
    rhs: readFile
- warn:
    lhs: Data.Text.IO.writeFile
    note: Function 'writeFile' is already exported from Relude
    name: Use 'writeFile' from Relude
    rhs: writeFile
- warn:
    lhs: System.IO.openFile
    note: Function 'openFile' is already exported from Relude
    name: Use 'openFile' from Relude
    rhs: openFile
- warn:
    lhs: Data.IORef.IORef
    note: Function 'IORef' is already exported from Relude
    name: Use 'IORef' from Relude
    rhs: IORef
- warn:
    lhs: Data.IORef.atomicModifyIORef
    note: Function 'atomicModifyIORef' is already exported from Relude
    name: Use 'atomicModifyIORef' from Relude
    rhs: atomicModifyIORef
- warn:
    lhs: Data.IORef.atomicModifyIORef'
    note: Function 'atomicModifyIORef'' is already exported from Relude
    name: Use 'atomicModifyIORef'' from Relude
    rhs: atomicModifyIORef'
- warn:
    lhs: Data.IORef.atomicWriteIORef
    note: Function 'atomicWriteIORef' is already exported from Relude
    name: Use 'atomicWriteIORef' from Relude
    rhs: atomicWriteIORef
- warn:
    lhs: Data.IORef.modifyIORef
    note: Function 'modifyIORef' is already exported from Relude
    name: Use 'modifyIORef' from Relude
    rhs: modifyIORef
- warn:
    lhs: Data.IORef.modifyIORef'
    note: Function 'modifyIORef'' is already exported from Relude
    name: Use 'modifyIORef'' from Relude
    rhs: modifyIORef'
- warn:
    lhs: Data.IORef.newIORef
    note: Function 'newIORef' is already exported from Relude
    name: Use 'newIORef' from Relude
    rhs: newIORef
- warn:
    lhs: Data.IORef.readIORef
    note: Function 'readIORef' is already exported from Relude
    name: Use 'readIORef' from Relude
    rhs: readIORef
- warn:
    lhs: Data.IORef.writeIORef
    note: Function 'writeIORef' is already exported from Relude
    name: Use 'writeIORef' from Relude
    rhs: writeIORef
- warn:
    lhs: Data.List.genericDrop
    note: Function 'genericDrop' is already exported from Relude
    name: Use 'genericDrop' from Relude
    rhs: genericDrop
- warn:
    lhs: Data.List.genericLength
    note: Function 'genericLength' is already exported from Relude
    name: Use 'genericLength' from Relude
    rhs: genericLength
- warn:
    lhs: Data.List.genericReplicate
    note: Function 'genericReplicate' is already exported from Relude
    name: Use 'genericReplicate' from Relude
    rhs: genericReplicate
- warn:
    lhs: Data.List.genericSplitAt
    note: Function 'genericSplitAt' is already exported from Relude
    name: Use 'genericSplitAt' from Relude
    rhs: genericSplitAt
- warn:
    lhs: Data.List.genericTake
    note: Function 'genericTake' is already exported from Relude
    name: Use 'genericTake' from Relude
    rhs: genericTake
- warn:
    lhs: Data.List.group
    note: Function 'group' is already exported from Relude
    name: Use 'group' from Relude
    rhs: group
- warn:
    lhs: Data.List.inits
    note: Function 'inits' is already exported from Relude
    name: Use 'inits' from Relude
    rhs: inits
- warn:
    lhs: Data.List.intercalate
    note: Function 'intercalate' is already exported from Relude
    name: Use 'intercalate' from Relude
    rhs: intercalate
- warn:
    lhs: Data.List.intersperse
    note: Function 'intersperse' is already exported from Relude
    name: Use 'intersperse' from Relude
    rhs: intersperse
- warn:
    lhs: Data.List.isPrefixOf
    note: Function 'isPrefixOf' is already exported from Relude
    name: Use 'isPrefixOf' from Relude
    rhs: isPrefixOf
- warn:
    lhs: Data.List.permutations
    note: Function 'permutations' is already exported from Relude
    name: Use 'permutations' from Relude
    rhs: permutations
- warn:
    lhs: Data.List.sort
    note: Function 'sort' is already exported from Relude
    name: Use 'sort' from Relude
    rhs: sort
- warn:
    lhs: Data.List.sortBy
    note: Function 'sortBy' is already exported from Relude
    name: Use 'sortBy' from Relude
    rhs: sortBy
- warn:
    lhs: Data.List.sortOn
    note: Function 'sortOn' is already exported from Relude
    name: Use 'sortOn' from Relude
    rhs: sortOn
- warn:
    lhs: Data.List.subsequences
    note: Function 'subsequences' is already exported from Relude
    name: Use 'subsequences' from Relude
    rhs: subsequences
- warn:
    lhs: Data.List.tails
    note: Function 'tails' is already exported from Relude
    name: Use 'tails' from Relude
    rhs: tails
- warn:
    lhs: Data.List.transpose
    note: Function 'transpose' is already exported from Relude
    name: Use 'transpose' from Relude
    rhs: transpose
- warn:
    lhs: Data.List.uncons
    note: Function 'uncons' is already exported from Relude
    name: Use 'uncons' from Relude
    rhs: uncons
- warn:
    lhs: Data.List.unfoldr
    note: Function 'unfoldr' is already exported from Relude
    name: Use 'unfoldr' from Relude
    rhs: unfoldr
- warn:
    lhs: Data.NonEmpty.NonEmpty
    note: Function 'NonEmpty' is already exported from Relude
    name: Use 'NonEmpty' from Relude
    rhs: NonEmpty
- warn:
    lhs: (Data.NonEmpty.:|)
    note: Operator '(:|)' is already exported from Relude
    name: Use ':|' from Relude
    rhs: (:|)
- warn:
    lhs: Data.NonEmpty.nonEmpty
    note: Function 'nonEmpty' is already exported from Relude
    name: Use 'nonEmpty' from Relude
    rhs: nonEmpty
- warn:
    lhs: Data.NonEmpty.head
    note: Function 'head' is already exported from Relude
    name: Use 'head' from Relude
    rhs: head
- warn:
    lhs: Data.NonEmpty.init
    note: Function 'init' is already exported from Relude
    name: Use 'init' from Relude
    rhs: init
- warn:
    lhs: Data.NonEmpty.last
    note: Function 'last' is already exported from Relude
    name: Use 'last' from Relude
    rhs: last
- warn:
    lhs: Data.NonEmpty.tail
    note: Function 'tail' is already exported from Relude
    name: Use 'tail' from Relude
    rhs: tail
- warn:
    lhs: GHC.Exts.sortWith
    note: Function 'sortWith' is already exported from Relude
    name: Use 'sortWith' from Relude
    rhs: sortWith
- warn:
    lhs: Control.Monad.Except.ExceptT
    note: Function 'ExceptT' is already exported from Relude
    name: Use 'ExceptT' from Relude
    rhs: ExceptT
- warn:
    lhs: Control.Monad.Except.runExceptT
    note: Function 'runExceptT' is already exported from Relude
    name: Use 'runExceptT' from Relude
    rhs: runExceptT
- warn:
    lhs: Control.Monad.Reader.MonadReader
    note: Function 'MonadReader' is already exported from Relude
    name: Use 'MonadReader' from Relude
    rhs: MonadReader
- warn:
    lhs: Control.Monad.Reader.Reader
    note: Function 'Reader' is already exported from Relude
    name: Use 'Reader' from Relude
    rhs: Reader
- warn:
    lhs: Control.Monad.Reader.ReaderT
    note: Function 'ReaderT' is already exported from Relude
    name: Use 'ReaderT' from Relude
    rhs: ReaderT
- warn:
    lhs: Control.Monad.Reader.runReaderT
    note: Function 'runReaderT' is already exported from Relude
    name: Use 'runReaderT' from Relude
    rhs: runReaderT
- warn:
    lhs: Control.Monad.Reader.ask
    note: Function 'ask' is already exported from Relude
    name: Use 'ask' from Relude
    rhs: ask
- warn:
    lhs: Control.Monad.Reader.asks
    note: Function 'asks' is already exported from Relude
    name: Use 'asks' from Relude
    rhs: asks
- warn:
    lhs: Control.Monad.Reader.local
    note: Function 'local' is already exported from Relude
    name: Use 'local' from Relude
    rhs: local
- warn:
    lhs: Control.Monad.Reader.reader
    note: Function 'reader' is already exported from Relude
    name: Use 'reader' from Relude
    rhs: reader
- warn:
    lhs: Control.Monad.Reader.runReader
    note: Function 'runReader' is already exported from Relude
    name: Use 'runReader' from Relude
    rhs: runReader
- warn:
    lhs: Control.Monad.Reader.withReader
    note: Function 'withReader' is already exported from Relude
    name: Use 'withReader' from Relude
    rhs: withReader
- warn:
    lhs: Control.Monad.Reader.withReaderT
    note: Function 'withReaderT' is already exported from Relude
    name: Use 'withReaderT' from Relude
    rhs: withReaderT
- warn:
    lhs: Control.Monad.State.Strict.MonadState
    note: Function 'MonadState' is already exported from Relude
    name: Use 'MonadState' from Relude
    rhs: MonadState
- warn:
    lhs: Control.Monad.State.Strict.State
    note: Function 'State' is already exported from Relude
    name: Use 'State' from Relude
    rhs: State
- warn:
    lhs: Control.Monad.State.Strict.StateT
    note: Function 'StateT' is already exported from Relude
    name: Use 'StateT' from Relude
    rhs: StateT
- warn:
    lhs: Control.Monad.State.Strict.runStateT
    note: Function 'runStateT' is already exported from Relude
    name: Use 'runStateT' from Relude
    rhs: runStateT
- warn:
    lhs: Control.Monad.State.Strict.evalState
    note: Function 'evalState' is already exported from Relude
    name: Use 'evalState' from Relude
    rhs: evalState
- warn:
    lhs: Control.Monad.State.Strict.evalStateT
    note: Function 'evalStateT' is already exported from Relude
    name: Use 'evalStateT' from Relude
    rhs: evalStateT
- warn:
    lhs: Control.Monad.State.Strict.execState
    note: Function 'execState' is already exported from Relude
    name: Use 'execState' from Relude
    rhs: execState
- warn:
    lhs: Control.Monad.State.Strict.execStateT
    note: Function 'execStateT' is already exported from Relude
    name: Use 'execStateT' from Relude
    rhs: execStateT
- warn:
    lhs: Control.Monad.State.Strict.get
    note: Function 'get' is already exported from Relude
    name: Use 'get' from Relude
    rhs: get
- warn:
    lhs: Control.Monad.State.Strict.gets
    note: Function 'gets' is already exported from Relude
    name: Use 'gets' from Relude
    rhs: gets
- warn:
    lhs: Control.Monad.State.Strict.modify
    note: Function 'modify' is already exported from Relude
    name: Use 'modify' from Relude
    rhs: modify
- warn:
    lhs: Control.Monad.State.Strict.modify'
    note: Function 'modify'' is already exported from Relude
    name: Use 'modify'' from Relude
    rhs: modify'
- warn:
    lhs: Control.Monad.State.Strict.put
    note: Function 'put' is already exported from Relude
    name: Use 'put' from Relude
    rhs: put
- warn:
    lhs: Control.Monad.State.Strict.runState
    note: Function 'runState' is already exported from Relude
    name: Use 'runState' from Relude
    rhs: runState
- warn:
    lhs: Control.Monad.State.Strict.state
    note: Function 'state' is already exported from Relude
    name: Use 'state' from Relude
    rhs: state
- warn:
    lhs: Control.Monad.State.Strict.withState
    note: Function 'withState' is already exported from Relude
    name: Use 'withState' from Relude
    rhs: withState
- warn:
    lhs: Control.Monad.Trans.MonadIO
    note: Function 'MonadIO' is already exported from Relude
    name: Use 'MonadIO' from Relude
    rhs: MonadIO
- warn:
    lhs: Control.Monad.Trans.MonadTrans
    note: Function 'MonadTrans' is already exported from Relude
    name: Use 'MonadTrans' from Relude
    rhs: MonadTrans
- warn:
    lhs: Control.Monad.Trans.lift
    note: Function 'lift' is already exported from Relude
    name: Use 'lift' from Relude
    rhs: lift
- warn:
    lhs: Control.Monad.Trans.liftIO
    note: Function 'liftIO' is already exported from Relude
    name: Use 'liftIO' from Relude
    rhs: liftIO
- warn:
    lhs: Control.Monad.Trans.Identity.IdentityT
    note: Function 'IdentityT' is already exported from Relude
    name: Use 'IdentityT' from Relude
    rhs: IdentityT
- warn:
    lhs: Control.Monad.Trans.Identity.runIdentityT
    note: Function 'runIdentityT' is already exported from Relude
    name: Use 'runIdentityT' from Relude
    rhs: runIdentityT
- warn:
    lhs: Control.Monad.Trans.Maybe.MaybeT
    note: Function 'MaybeT' is already exported from Relude
    name: Use 'MaybeT' from Relude
    rhs: MaybeT
- warn:
    lhs: Control.Monad.Trans.Maybe.maybeToExceptT
    note: Function 'maybeToExceptT' is already exported from Relude
    name: Use 'maybeToExceptT' from Relude
    rhs: maybeToExceptT
- warn:
    lhs: Control.Monad.Trans.Maybe.exceptToMaybeT
    note: Function 'exceptToMaybeT' is already exported from Relude
    name: Use 'exceptToMaybeT' from Relude
    rhs: exceptToMaybeT
- warn:
    lhs: Control.Monad.MonadPlus
    note: Function 'MonadPlus' is already exported from Relude
    name: Use 'MonadPlus' from Relude
    rhs: MonadPlus
- warn:
    lhs: Control.Monad.mzero
    note: Function 'mzero' is already exported from Relude
    name: Use 'mzero' from Relude
    rhs: mzero
- warn:
    lhs: Control.Monad.mplus
    note: Function 'mplus' is already exported from Relude
    name: Use 'mplus' from Relude
    rhs: mplus
- warn:
    lhs: Control.Monad.filterM
    note: Function 'filterM' is already exported from Relude
    name: Use 'filterM' from Relude
    rhs: filterM
- warn:
    lhs: Control.Monad.forever
    note: Function 'forever' is already exported from Relude
    name: Use 'forever' from Relude
    rhs: forever
- warn:
    lhs: Control.Monad.join
    note: Function 'join' is already exported from Relude
    name: Use 'join' from Relude
    rhs: join
- warn:
    lhs: Control.Monad.mapAndUnzipM
    note: Function 'mapAndUnzipM' is already exported from Relude
    name: Use 'mapAndUnzipM' from Relude
    rhs: mapAndUnzipM
- warn:
    lhs: Control.Monad.mfilter
    note: Function 'mfilter' is already exported from Relude
    name: Use 'mfilter' from Relude
    rhs: mfilter
- warn:
    lhs: Control.Monad.replicateM
    note: Function 'replicateM' is already exported from Relude
    name: Use 'replicateM' from Relude
    rhs: replicateM
- warn:
    lhs: Control.Monad.replicateM_
    note: Function 'replicateM_' is already exported from Relude
    name: Use 'replicateM_' from Relude
    rhs: replicateM_
- warn:
    lhs: Control.Monad.zipWithM
    note: Function 'zipWithM' is already exported from Relude
    name: Use 'zipWithM' from Relude
    rhs: zipWithM
- warn:
    lhs: Control.Monad.zipWithM_
    note: Function 'zipWithM_' is already exported from Relude
    name: Use 'zipWithM_' from Relude
    rhs: zipWithM_
- warn:
    lhs: (Control.Monad.<$!>)
    note: Operator '(<$!>)' is already exported from Relude
    name: Use '<$!>' from Relude
    rhs: (<$!>)
- warn:
    lhs: (Control.Monad.<=<)
    note: Operator '(<=<)' is already exported from Relude
    name: Use '<=<' from Relude
    rhs: (<=<)
- warn:
    lhs: (Control.Monad.=<<)
    note: Operator '(=<<)' is already exported from Relude
    name: Use '=<<' from Relude
    rhs: (=<<)
- warn:
    lhs: (Control.Monad.>=>)
    note: Operator '(>=>)' is already exported from Relude
    name: Use '>=>' from Relude
    rhs: (>=>)
- warn:
    lhs: Control.Monad.Fail.MonadFail
    note: Function 'MonadFail' is already exported from Relude
    name: Use 'MonadFail' from Relude
    rhs: MonadFail
- warn:
    lhs: Data.Maybe.catMaybes
    note: Function 'catMaybes' is already exported from Relude
    name: Use 'catMaybes' from Relude
    rhs: catMaybes
- warn:
    lhs: Data.Maybe.fromMaybe
    note: Function 'fromMaybe' is already exported from Relude
    name: Use 'fromMaybe' from Relude
    rhs: fromMaybe
- warn:
    lhs: Data.Maybe.isJust
    note: Function 'isJust' is already exported from Relude
    name: Use 'isJust' from Relude
    rhs: isJust
- warn:
    lhs: Data.Maybe.isNothing
    note: Function 'isNothing' is already exported from Relude
    name: Use 'isNothing' from Relude
    rhs: isNothing
- warn:
    lhs: Data.Maybe.listToMaybe
    note: Function 'listToMaybe' is already exported from Relude
    name: Use 'listToMaybe' from Relude
    rhs: listToMaybe
- warn:
    lhs: Data.Maybe.mapMaybe
    note: Function 'mapMaybe' is already exported from Relude
    name: Use 'mapMaybe' from Relude
    rhs: mapMaybe
- warn:
    lhs: Data.Maybe.maybeToList
    note: Function 'maybeToList' is already exported from Relude
    name: Use 'maybeToList' from Relude
    rhs: maybeToList
- warn:
    lhs: Data.Either.isLeft
    note: Function 'isLeft' is already exported from Relude
    name: Use 'isLeft' from Relude
    rhs: isLeft
- warn:
    lhs: Data.Either.isRight
    note: Function 'isRight' is already exported from Relude
    name: Use 'isRight' from Relude
    rhs: isRight
- warn:
    lhs: Data.Either.lefts
    note: Function 'lefts' is already exported from Relude
    name: Use 'lefts' from Relude
    rhs: lefts
- warn:
    lhs: Data.Either.partitionEithers
    note: Function 'partitionEithers' is already exported from Relude
    name: Use 'partitionEithers' from Relude
    rhs: partitionEithers
- warn:
    lhs: Data.Either.rights
    note: Function 'rights' is already exported from Relude
    name: Use 'rights' from Relude
    rhs: rights
- warn:
    lhs: Data.Monoid.All
    note: Function 'All' is already exported from Relude
    name: Use 'All' from Relude
    rhs: All
- warn:
    lhs: Data.Monoid.getAll
    note: Function 'getAll' is already exported from Relude
    name: Use 'getAll' from Relude
    rhs: getAll
- warn:
    lhs: Data.Monoid.Alt
    note: Function 'Alt' is already exported from Relude
    name: Use 'Alt' from Relude
    rhs: Alt
- warn:
    lhs: Data.Monoid.getAlt
    note: Function 'getAlt' is already exported from Relude
    name: Use 'getAlt' from Relude
    rhs: getAlt
- warn:
    lhs: Data.Monoid.Any
    note: Function 'Any' is already exported from Relude
    name: Use 'Any' from Relude
    rhs: Any
- warn:
    lhs: Data.Monoid.getAny
    note: Function 'getAny' is already exported from Relude
    name: Use 'getAny' from Relude
    rhs: getAny
- warn:
    lhs: Data.Monoid.Dual
    note: Function 'Dual' is already exported from Relude
    name: Use 'Dual' from Relude
    rhs: Dual
- warn:
    lhs: Data.Monoid.getDual
    note: Function 'getDual' is already exported from Relude
    name: Use 'getDual' from Relude
    rhs: getDual
- warn:
    lhs: Data.Monoid.Endo
    note: Function 'Endo' is already exported from Relude
    name: Use 'Endo' from Relude
    rhs: Endo
- warn:
    lhs: Data.Monoid.appEndo
    note: Function 'appEndo' is already exported from Relude
    name: Use 'appEndo' from Relude
    rhs: appEndo
- warn:
    lhs: Data.Monoid.First
    note: Function 'First' is already exported from Relude
    name: Use 'First' from Relude
    rhs: First
- warn:
    lhs: Data.Monoid.getFirst
    note: Function 'getFirst' is already exported from Relude
    name: Use 'getFirst' from Relude
    rhs: getFirst
- warn:
    lhs: Data.Monoid.Last
    note: Function 'Last' is already exported from Relude
    name: Use 'Last' from Relude
    rhs: Last
- warn:
    lhs: Data.Monoid.getLast
    note: Function 'getLast' is already exported from Relude
    name: Use 'getLast' from Relude
    rhs: getLast
- warn:
    lhs: Data.Monoid.Product
    note: Function 'Product' is already exported from Relude
    name: Use 'Product' from Relude
    rhs: Product
- warn:
    lhs: Data.Monoid.getProduct
    note: Function 'getProduct' is already exported from Relude
    name: Use 'getProduct' from Relude
    rhs: getProduct
- warn:
    lhs: Data.Monoid.Sum
    note: Function 'Sum' is already exported from Relude
    name: Use 'Sum' from Relude
    rhs: Sum
- warn:
    lhs: Data.Monoid.getSum
    note: Function 'getSum' is already exported from Relude
    name: Use 'getSum' from Relude
    rhs: getSum
- warn:
    lhs: Data.Semigroup.Option
    note: Function 'Option' is already exported from Relude
    name: Use 'Option' from Relude
    rhs: Option
- warn:
    lhs: Data.Semigroup.getOption
    note: Function 'getOption' is already exported from Relude
    name: Use 'getOption' from Relude
    rhs: getOption
- warn:
    lhs: Data.Semigroup.Semigroup
    note: Function 'Semigroup' is already exported from Relude
    name: Use 'Semigroup' from Relude
    rhs: Semigroup
- warn:
    lhs: Data.Semigroup.sconcat
    note: Function 'sconcat' is already exported from Relude
    name: Use 'sconcat' from Relude
    rhs: sconcat
- warn:
    lhs: Data.Semigroup.stimes
    note: Function 'stimes' is already exported from Relude
    name: Use 'stimes' from Relude
    rhs: stimes
- warn:
    lhs: (Data.Semigroup.<>)
    note: Operator '(<>)' is already exported from Relude
    name: Use '<>' from Relude
    rhs: (<>)
- warn:
    lhs: Data.Semigroup.WrappedMonoid
    note: Function 'WrappedMonoid' is already exported from Relude
    name: Use 'WrappedMonoid' from Relude
    rhs: WrappedMonoid
- warn:
    lhs: Data.Semigroup.cycle1
    note: Function 'cycle1' is already exported from Relude
    name: Use 'cycle1' from Relude
    rhs: cycle1
- warn:
    lhs: Data.Semigroup.mtimesDefault
    note: Function 'mtimesDefault' is already exported from Relude
    name: Use 'mtimesDefault' from Relude
    rhs: mtimesDefault
- warn:
    lhs: Data.Semigroup.stimesIdempotent
    note: Function 'stimesIdempotent' is already exported from Relude
    name: Use 'stimesIdempotent' from Relude
    rhs: stimesIdempotent
- warn:
    lhs: Data.Semigroup.stimesIdempotentMonoid
    note: Function 'stimesIdempotentMonoid' is already exported from Relude
    name: Use 'stimesIdempotentMonoid' from Relude
    rhs: stimesIdempotentMonoid
- warn:
    lhs: Data.Semigroup.stimesMonoid
    note: Function 'stimesMonoid' is already exported from Relude
    name: Use 'stimesMonoid' from Relude
    rhs: stimesMonoid
- warn:
    lhs: Data.ByteString.ByteString
    note: Function 'ByteString' is already exported from Relude
    name: Use 'ByteString' from Relude
    rhs: ByteString
- warn:
    lhs: Data.String.IsString
    note: Function 'IsString' is already exported from Relude
    name: Use 'IsString' from Relude
    rhs: IsString
- warn:
    lhs: Data.String.fromString
    note: Function 'fromString' is already exported from Relude
    name: Use 'fromString' from Relude
    rhs: fromString
- warn:
    lhs: Data.Text.Text
    note: Function 'Text' is already exported from Relude
    name: Use 'Text' from Relude
    rhs: Text
- warn:
    lhs: Data.Text.lines
    note: Function 'lines' is already exported from Relude
    name: Use 'lines' from Relude
    rhs: lines
- warn:
    lhs: Data.Text.unlines
    note: Function 'unlines' is already exported from Relude
    name: Use 'unlines' from Relude
    rhs: unlines
- warn:
    lhs: Data.Text.words
    note: Function 'words' is already exported from Relude
    name: Use 'words' from Relude
    rhs: words
- warn:
    lhs: Data.Text.unwords
    note: Function 'unwords' is already exported from Relude
    name: Use 'unwords' from Relude
    rhs: unwords
- warn:
    lhs: Data.Text.Encoding.decodeUtf8'
    note: Function 'decodeUtf8'' is already exported from Relude
    name: Use 'decodeUtf8'' from Relude
    rhs: decodeUtf8'
- warn:
    lhs: Data.Text.Encoding.decodeUtf8With
    note: Function 'decodeUtf8With' is already exported from Relude
    name: Use 'decodeUtf8With' from Relude
    rhs: decodeUtf8With
- warn:
    lhs: Data.Text.Encoding.Error.OnDecodeError
    note: Function 'OnDecodeError' is already exported from Relude
    name: Use 'OnDecodeError' from Relude
    rhs: OnDecodeError
- warn:
    lhs: Data.Text.Encoding.Error.OnError
    note: Function 'OnError' is already exported from Relude
    name: Use 'OnError' from Relude
    rhs: OnError
- warn:
    lhs: Data.Text.Encoding.Error.UnicodeException
    note: Function 'UnicodeException' is already exported from Relude
    name: Use 'UnicodeException' from Relude
    rhs: UnicodeException
- warn:
    lhs: Data.Text.Encoding.Error.lenientDecode
    note: Function 'lenientDecode' is already exported from Relude
    name: Use 'lenientDecode' from Relude
    rhs: lenientDecode
- warn:
    lhs: Data.Text.Encoding.Error.strictDecode
    note: Function 'strictDecode' is already exported from Relude
    name: Use 'strictDecode' from Relude
    rhs: strictDecode
- warn:
    lhs: Text.Read.Read
    note: Function 'Read' is already exported from Relude
    name: Use 'Read' from Relude
    rhs: Read
- warn:
    lhs: Text.Read.readMaybe
    note: Function 'readMaybe' is already exported from Relude
    name: Use 'readMaybe' from Relude
    rhs: readMaybe
- warn:
    lhs: (liftIO (newEmptyMVar ))
    note: If you import 'newEmptyMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: newEmptyMVar
- warn:
    lhs: (liftIO (newMVar x))
    note: If you import 'newMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: newMVar
- warn:
    lhs: (liftIO (putMVar x y))
    note: If you import 'putMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putMVar
- warn:
    lhs: (liftIO (readMVar x))
    note: If you import 'readMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: readMVar
- warn:
    lhs: (liftIO (swapMVar x y))
    note: If you import 'swapMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: swapMVar
- warn:
    lhs: (liftIO (takeMVar x))
    note: If you import 'takeMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: takeMVar
- warn:
    lhs: (liftIO (tryPutMVar x y))
    note: If you import 'tryPutMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: tryPutMVar
- warn:
    lhs: (liftIO (tryReadMVar x))
    note: If you import 'tryReadMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: tryReadMVar
- warn:
    lhs: (liftIO (tryTakeMVar x))
    note: If you import 'tryTakeMVar' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: tryTakeMVar
- warn:
    lhs: (liftIO (atomically x))
    note: If you import 'atomically' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: atomically
- warn:
    lhs: (liftIO (newTVarIO x))
    note: If you import 'newTVarIO' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: newTVarIO
- warn:
    lhs: (liftIO (readTVarIO x))
    note: If you import 'readTVarIO' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: readTVarIO
- warn:
    lhs: (liftIO (exitWith x))
    note: If you import 'exitWith' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: exitWith
- warn:
    lhs: (liftIO (exitFailure ))
    note: If you import 'exitFailure' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: exitFailure
- warn:
    lhs: (liftIO (exitSuccess ))
    note: If you import 'exitSuccess' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: exitSuccess
- warn:
    lhs: (liftIO (die x))
    note: If you import 'die' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: die
- warn:
    lhs: (liftIO (appendFile x y))
    note: If you import 'appendFile' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: appendFile
- warn:
    lhs: (liftIO (openFile x y))
    note: If you import 'openFile' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: openFile
- warn:
    lhs: (liftIO (readFile x))
    note: If you import 'readFile' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: readFile
- warn:
    lhs: (liftIO (writeFile x y))
    note: If you import 'writeFile' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: writeFile
- warn:
    lhs: (liftIO (newIORef x))
    note: If you import 'newIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: newIORef
- warn:
    lhs: (liftIO (readIORef x))
    note: If you import 'readIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: readIORef
- warn:
    lhs: (liftIO (writeIORef x y))
    note: If you import 'writeIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: writeIORef
- warn:
    lhs: (liftIO (modifyIORef x y))
    note: If you import 'modifyIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: modifyIORef
- warn:
    lhs: (liftIO (modifyIORef' x y))
    note: If you import 'modifyIORef'' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: modifyIORef'
- warn:
    lhs: (liftIO (atomicModifyIORef x y))
    note: If you import 'atomicModifyIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: atomicModifyIORef
- warn:
    lhs: (liftIO (atomicModifyIORef' x y))
    note: If you import 'atomicModifyIORef'' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: atomicModifyIORef'
- warn:
    lhs: (liftIO (atomicWriteIORef x y))
    note: If you import 'atomicWriteIORef' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: atomicWriteIORef
- warn:
    lhs: (liftIO (getLine ))
    note: If you import 'getLine' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: getLine
- warn:
    lhs: (liftIO (print x))
    note: If you import 'print' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: print
- warn:
    lhs: (liftIO (putStr x))
    note: If you import 'putStr' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putStr
- warn:
    lhs: (liftIO (putStrLn x))
    note: If you import 'putStrLn' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putStrLn
- warn:
    lhs: (liftIO (putText x))
    note: If you import 'putText' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putText
- warn:
    lhs: (liftIO (putTextLn x))
    note: If you import 'putTextLn' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putTextLn
- warn:
    lhs: (liftIO (putLText x))
    note: If you import 'putLText' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putLText
- warn:
    lhs: (liftIO (putLTextLn x))
    note: If you import 'putLTextLn' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putLTextLn
- warn:
    lhs: (liftIO (putBS x))
    note: If you import 'putBS' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putBS
- warn:
    lhs: (liftIO (putBSLn x))
    note: If you import 'putBSLn' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putBSLn
- warn:
    lhs: (liftIO (putLBS x))
    note: If you import 'putLBS' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putLBS
- warn:
    lhs: (liftIO (putLBSLn x))
    note: If you import 'putLBSLn' from Relude, it's already lifted
    name: ! '''liftIO'' is not needed'
    rhs: putLBSLn
